

# Array

**본 내용은 노마드 코더님의 강의를 토대로 작성하였습니다.**



## 1. Time Complexity(시간 복잡도)

* 데이터 구조의 오퍼레이션 혹은 알고리즘이 얼마나 빠르고 느린지 측정하는 방법
* 실제 시간을 재는 것이 아닌, 얼마나 많은 **단계**가 있는가로 측정
* **단계**가 적을 수록 훌륭한 알고리즘



## 2. Memory

### volatile(휘발성)

* 컴퓨터를 끄면 모든 데이터가 사라짐
* RAM
  * Random Access Memory
  * 하드 드라이브보다 빠름
  * 데이터 접속을 랜덤으로할 수 있다.
* 프로그램이 돌아가고, 변수를 생성할 때 RAM에 저장



### non-volatile(비휘발성)

* 하드 드라이브
* 컴퓨터를 껐다가 다시 켜도 데이터는 그대로



## 3. 메모리 관점에서의 배열

* 배열을 만들기 전, 컴퓨터에게 배열의 길이를 예약 / 할당
* 메모리 안에서 나란히 위치
* 컴퓨터는 배열이 얼마나 긴지, 최대 길이, 시작 지점을 알고 있다.



## 4. Operation



### Reading

* 배열은 0부터 인덱싱
* 위치를 알면 배열의 데이터에 접근 가능
* 빠른 속도로 읽을 수 있다.
  * 컴퓨터가 배열이 어디서 시작하는지 알기 때문
* 많은 자료를 저장시에는 배열이 유용
  * Random Access 덕분
* 배열이 얼마나 길던지, 인덱스에서 요소를 읽어내는 속도는 동일



### Searching

* 검색은 해당 값이 배열에 있는 지 없는 지 모르므로 시간이 걸린다.
* **선형 검색**
  * 배열에서 값을 찾으려면 아이템을 하나하나 찾아봐야한다.
* 가장 좋은 시나리오: 찾는 아이템이 인덱스 첫번째에 있을 때
* 보통 시나리오: 찾는 아이템이 배열 중간에 있을 때
* 가장 나쁜 시나리오: 찾는 아이템이 인덱스 마지막에 있을 때
  * 그보다 안좋은 경우: 찾는 아이템이 없는 경우



### Insert(Add)

* 배열을 만들 때에는 메모리 공간을 미리 확보
* 꽉 차지 않은 배열에 요소를 추가할 때
  * 최고 시나리오: 요소를 배열의 맨 끝에 추가
    * 컴퓨터는 배열이 어디서 시작하고, 얼마나 긴지 기억하므로 빠르게 완료
  * 보통 시나리오: 요소를 배열의 중간에 추가
    * 요소를 중간에 추가하기위해 뒤의 배열을 옮겨 공간을 만들어야 한다.
  * 최악의 시나리오: 요소를 배열의 맨앞에 추가
    * 모든 요소를 뒤로 옮겨야 한다.
* 꽉 찬 배열에 요소를 추가할 때
  * 더 큰 배열을 만들어서 이전 배열을 복사하고 추가해야 한다.



### Delete

* 최고 시나리오: 마지막 요소를 삭제할 때
* 보통의 시나리오: 중간 요소를 삭제할 때
  * 중간의 요소를 삭제 후, 중간의 공백을 채우기 위해서 중간 뒤의 배열의 값을 움직인다
* 최악의 시나리오: 가장 앞 요소를 삭제할 때
  * 삭제 후, 빈공간 채우기 위해서 모든 나머지 값이 앞으로 이동



## 5. 정리

* 배열을 읽는 매우 빠르다.
* 배열을 검색, 삽입, 삭제하는 것은 아이템이 많아질 수록 느려진다.
* 배열의 추가, 삭제는 맨 뒤에서 이뤄지는 것이 좋다.

# Reference

[[노마드코더]Array 배열 기초개념? 10분만에 정리해줌!](https://www.youtube.com/watch?v=NFETSCJON2M&list=PL7jH19IHhOLMdHvl3KBfFI70r9P0lkJwL&index=2)