# Refactoring - 캡슐화(1)

**본 내용은 마틴 파울러의 Refactoring 2판을 토대로 작성되었습니다.**



## 캡슐화

* 클래스는 본래 정보를 숨기는 용도로 설계
  * 내부 정보뿐 아니라 클래스 사이의 연결 관계를 숨기는 데도 유용



## 1. 레코드 캡슐화하기

```JavaScript
organization = {name: "애크미 구스베리", country: "GB"};
```

```JavaScript
class Organization = {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }
  get name() {return this._name;}
	set name(arg) {this._name = arg;}
	get country() {return this._country;}
	set country(arg) {this._country = arg;}
}
```



### 설명

* 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호
* 객체를 사용하면 어떻게 저장했는 지를 숨긴 채 값을 메서드로 제공 가능
* 캡슐화하면 이름을 바꿀 때도 좋음
  * 필드 이름을 바꿔도 기존 이름과 새 이름 모두를 각각의 메서드로 제공 가능
  * 새로운 매서드로 옮겨갈 때까지 점진적으로 수행 가능



### 절차

1. 레코드를 담은 변수를 캡슐화
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 원본 레코드를 반환하는 접근자도 정의하고 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정
3. 테스트
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만듦
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꿈
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거
7. 테스트
8. 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용



## 2. 컬렉션 켭슐화하기

```JavaScript
class Person {
  get courses() {return this._courses;}
  set courses(aList) {this._courses = aList;}
}
```



```JavaScript
class Person {
  get courses() {return this._courses.slice();}
  addCourse(aCourse) {...}
  removeCourse(aCourse) {...}
}
```



### 설명

* 컬렉션 변수로의 접근을 캡슐화하면서, 게터가 컬렉션 자체를 반환하도록 하면 컬렉션의 원소들이 바뀌어버릴 수 있음
  * 이런 문제를 방지하기 위해 컬렉션을 감싼 클래스에 add(), remove()라는 이름의 컬렉션 변경자 메서드를 만듦
* 컬렉션 게터가 원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는 것이 나음



### 절차

1. 컬렉션을 변수 캡슐화 하기
2. 컬렉션에 원소를 추가/제거하는 함수를 추가
3. 정적 검사 수행
4. 컬렉션을 참조하는 부분을 모두 찾음. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정
5. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기전용 프락시나 복제본을 반환하게 함
6. 테스트



## 3. 기본형을 객체로 바꾸기

```JavaScript
orders.filter(o => "high" === o.priority
             	|| "rush" === o.priority);
```

```JavaScript
orders.filter(o => o.priority.higherThan(new Priority("normal")))
```



### 설명

* 개발 초기에는 단순한 정보를 숫자나 문자열 같은 간단한 데이터 항목으로 표현
  * 개발이 진행되며, 더 이상 간단하지 않게 변함
  * 중복 코드가 늘어나서 사용할 때마다 드는 노력도 늘어남
* 출력 이상의 기능이 필요해지면 그 데이터를 표현하는 전용 클래스를 정의할 것
  * 특별한 동작이 필요해지면 클래스에 추가



### 절차

1. 변수를 캡슐화
2. 단순한 값 클래스를 만듦. 생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 게터를 추가
3. 정적 검사를 수행
4. 값 클래스의 인스턴스를 새로 만들어서 필드에 저장하도록 세터를 수정
5. 테스트
6. 함수 이름을 바꾸면 원본 접근자의 동작을 더 잘드러낼 수 있는지 검토



## 4. 임시 변수를 질의 함수로 바꾸기

```JavaScript
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
  return basePrice * 0.95;
else
  return basePrice * 0.98;
```



```JavaScript
get basePrice() {this._quantity * this._itemPrice;}
...
if (this.basePrice > 1000)
	return this.basePrice * 0.95;
else
  return this.basePrice * 0.98;
```



### 설명

* 코드의 결괏값을 다시 뒤에서 참조할 목적으로 임시 변수를 사용
  * 임시 변수를 사용하면 값을 계산하는 코드가 반복되는 것을 줄이고 값의 의미를 설명 가능하여 유용
  * 한 걸음 나아가 함수로 만드는 것이 더 나을 수도 있음
* 긴 함수의 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면 일이 수월
  * 추출한 함수에 변수를 따로 전달할 필요가 없어지기 때문
  * 추출한 함수와 원래 함수의 경계가 더 분명해짐
* 클래스 안에서 이 리팩터링을 수행하면 효과가 큼
* 변수에 값을 한 번 더 대입한 뒤 더 복잡한 코드 덩어리에서 여러 차례 다시 대입하는 경우는 모두 질의 함수로 추출
* 스냅숏 용도로 쓰이는 변수에는 이 리팩터링을 적용하지 말 것



### 절차

1. 변수가 사용되기 전에 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인
2. 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만듦
3. 테스트
4. 변수 대입문을 함수로 추출
5. 테스트
6. 변수 인라인하기로 임시 변수 제거

