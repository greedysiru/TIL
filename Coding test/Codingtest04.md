# [동빈나]이코테 2021 강의 몰아보기(4) (2021.1.1)



**본 내용은 해당 [강의](https://www.youtube.com/watch?v=2zjoKjt97vQ&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=2) 토대로 작성**



# 그리디 알고리즘

## 1. 그리디 알고리즘 개요

* 그리디 알고리즘(탐욕법)은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 뜻함
* 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
* **정당성 분석**이 중요
  * 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
* 일반적인 상황에서 **최적의 해를 보장할 수 없는 때가 많다.**
* **코딩 테스트**에서 대부분의 그리디 문제는 **탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론**할 수 있어야 풀리도록 출제



## 2. 그리디 유형 문제 풀이

## <문제> 거스름 돈

### 문제 설명

> 카운터에 거스름돈으로 사용할 500원, 100원, 50원, 10원이 무한이 존재
>
> 손님에게 거슬러 줄 돈이 N(10의 배수)원일 때 필요한 최소 동전의 개수



### 문제 해결 아이디어

* **가장 큰 화폐 단위**부터 돈을 거슬러 준다.
* 500원 -> 100원 -> 50원 -> 10원
* N = 1,260일 때의 예시

|      화폐 단위       | 500  | 100  |  50  |  10  |
| :------------------: | :--: | :--: | :--: | :--: |
| **손님이 받은 개수** |  2   |  2   |  1   |  1   |



### 정당성 분석

* 가지고 있는 동전 중에서 가장 큰 단위가 항상 작은 단위의 배수이므로 다른 해가 나올 수 없다.
* 500원, 400원, 100원인 경우는 최적의 해를 보장할 수 없음
* 그리디 알고리즘은 풀이를 위한 최소한의 아이디어를 떠올리고 **정당성 검토를 해야한다.**



### 답안 예시 (Python)

```python
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
array = [500, 100, 50, 10]

for coin in array:
    count += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기(나눈 몫)
    n %= coin # 나눈 나머지 입력
    
print(count)
```



### 시간 복잡도 분석

* 화폐의 종류가 K라고 할 때, 소스코드의 시간 복잡도는 **O(K)**
* 동전의 총 종류에만 영향을 받음



## <문제> 1이 될 때까지

### 문제 설명

> N이 1이 될 때까지 아래의 두 과정 중 하나를 반복적으로 선택하여 수행
>
> 1 ) N에서 1을 뺀다.
>
> 2 ) N을 K로 나눈다. (단, 나누어 떨어질 때)
>
> N이 1이 될 떄까지 과정울 수행해야 하는 최소 횟수를 구하여라



### 문제 조건

* 풀이 시간 : 15분
* 시간제한 : 2초
* 메모리 제한 : 128MB
* 입력 조건: 첫째 줄에 N(1 <= N <= 100,000), K(2 <= K <= 100,000)가 공백을 기준으로 각각 주어짐(자연수)
* 출력 조건: 첫째 줄에 수행 횟수의 최솟값을 출력



### 문제 해결 아이디어

* 주어진 N에 대하여 **최대한 많이 나누기** 수행
* N의 값을 줄일 때 **2 이상의 수로 나누는 작업**이 **1을 빼는 작업보다** 수를 훨씬 많이 줄일 수 있다.



### 정당성 분석

* 덧셈보다 나눗셈이 수를 빠르게 줄인다.
* K가 2 이상이기만 하면, 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있다.



### 답안 예시

```python
# N, K를 공백을 기준으로 입력 받기
n, k = map(int, input().split())

result = 0

while True:
    # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
    target = (n // k) * k
    result += (n - target)
    n = target
    # N이 K보다 작아, 나눌 수 없을 때 반복문 탈출
    if n < k:
        break
    # K로 나누기
    result += 1
    n //= k
    
# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)        
```

* target = (n // k) * k는 n을 k로 나누어 떨어질 때 까지 뺄 수 있다. 소수점을 제외한 몫이 나오고 다시 k를 곱해주기 때문이다.
* 이 테크닉을 사용하면, 프로그램이 빨리 실행될 수 있고 큰 수라고 하더라도 로그시간 복잡도로 해결할 수 있다.



## <문제> 곱하기 혹은 더하기

### 문제 설명

> 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어진다.
>
> 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+'연산자를 하여 결과적으로 만들어질 수 있는 가장 큰 수를 구하여라
>
> 모든 연산은 왼쪽에서부터 순서대로



### 문제 조건

* 풀이 시간 : 30분
* 시간 제한 : 1초
* 메모리 제한 : 128MB
* 입력 조건 : 첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어짐 (1 <= S의 길이 <= 20)
* 출력 조건 : 첫째 줄에 만들어질 수 있는 가장 큰 수 출력



### 문제 해결 아이디어

* 대부분의 경우 '+'보다 'x'가 값을 더 크게 만듦
* '0' 혹은 '1'인 경우 더하기를 수행하는 것이 효율적
* **두 수가 모두 2 이상 -> 곱하기**



### 답안 예시

```python
data = input()

# 첫 번째 문자를 숫자로 변경하여 대입
result = int(data[0])

for i in range(1, len(data):
    # 두 수 중 하나라도 '0' 혹은 '1'인 경우, 더하기 수행
    num = int(data[i])
    if num <= 1 or result <= 1:
        result += num
    else:
        result *= num
       
print(result)
```



## <문제> 모험가 길드 : 문제 설명

### 문제 설명

> 한 마을에 모험가가 N명 있다.
>
> 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높을 수록 위험 상황에서 제대로 대처할 능력이 떨어진다.
>
> 길드장은 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여하도록 했다.
>
> N명의 모험가 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹의 최댓값을 구하여라
>
> 몇 명의 모험가는 남아있어도 된다.



### 문제 조건

* 풀이 시간 : 30분
* 시간 제한 : 1초
* 메모리 제한 : 128MB
* 입력 조건 
  * 첫째 줄에 모험가의 수 N이 주어진다.(1 <= N <= 100,000)
  * 둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 공백으로 구분된다.
* 출력 조건 : 여행을 떠날 수 있는 그룹의 최댓값을 출력



### 문제 해결 아이디어

* 오름차순 정렬 이후에 공포도가 가장 낮은 모험가부터 하나씩 확인
* 앞에서부터 공포도를 하나씩 확인
  * 현재 그룹에 포함된 모험가의 수 >= 현재 확인하고 있는 공포도 -> 그룹으로 설정
* 공포도가 오름차순으로 정렬되어 있어, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성



### 답안 예시

```python
n = int(input())
data = list(map(int, input().split())) # 정수형 데이터를 받아 리스트로 입력
data.sort() # 오름차순 정렬

result = 0 # 총 그룹의 수
count = 0 # 현재 그룹에 포함된 모험가의 수

for i in data: # 공포도를 낮은 것 부터 하나씩 확인
    count += 1 # 현재 그룹에 해당 모험가 포함시키기
    if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
        result += 1 # 총 그룹의 수 증가
        count = 0 # 현재 그룹에 포함된 모험가의 수 초기화
        
print(result) # 총 그룹의 수 출력
```



# 구현 : 시뮬레이션과 완전 탐색

## 1. 구현 개요

* 구현(Implementation) :머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
* 알고리즘 대회에서 구현 유형의 문제란?
  * **풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제**
* 구현 유형의 예시
  * 알고리즘은 간단, 코드가 긴 문제
  * 실수 연산을 다루고, 특정 소수점 자리까지 출력해야하는 문제
  * 문자열을 특정한 기준에 따라서 끊어 처리
  * 적절한 라이브러리를 찾아 사용해야하는 문제
* 일반적으로 2차원 공간은 **행렬(Matrix)**의 의미로 사용

```python
# 5행 5열 행렬 만들기
for i in range(5):
    for j in range(5):
        print('(','i, ','j'')', end=' ')
    print()
```



* 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 **방향 벡터**가 자주 활용

```python 
    # 동, 북, 서, 남
dx = [0, -1, 0, 1]       #x는 행, y는 열
dy = [1, 0, -1, 0]

# 현재 위치
x, y = 2, 2

for i in range(4):
    # 다음 위치
    nx = x + dx[i]
    ny = y + dy[i]
    print(nx, ny) # (2,2)에서 동, 북, 서, 남 순으로 출력
```



## 2. 구현 문제 풀이

## <문제> 상하좌우 

### 문제 설명

>  여행가 A는 N x N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 x 1 크기의 정사각형으로 나누어져 있다.
>
> 가장 왼쪽 위 좌표는 (1,1), 가장 오른쪽 아래 좌표는 (N,N)
>
> 여행가 A는 상, 하, 좌, 우 방향으로 이동, 시작 좌표는 항상 (1,1)
>
> 이동 계획서는 아래와 같다
>
> L:  왼쪽으로 한 칸 이동
>
> R: 오른쪽으로 한 칸 이동
>
> U: 위로 한 칸 이동
>
> D: 아래로 한 칸 이동
>
> N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시



### 문제 조건

* 풀이 시간 : 15분
* 시간제한 : 2초
* 메모리 제한 : 128MB
* 입력 조건
  * 첫째 줄에 공간의 크기를 나타내는 N이 주어진다. (1 <= N <= 100)
  * 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다. (1 <= 이동 횟수 <= 100)
* 출력 조건 : 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X, Y)를 공백을 기준으로 구분하여 출력



### 문제 해결 아이디어

* 요구사항대로 충실히 구현하는 문제
* 일련의 명령에 따라서 개체를 차례대로 이동시키는 **시뮬레이션(Simulation) 유형**으로도 분류
  * 시뮬레이션 유형, 구현 유형, 완전 탐색 유형은 서로 유사한 점이 많다.



### 답안 예시

```python
# N 입력 받기
n = int(input())
x, y = 1, 1
plans = input().split()

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# 이동 계획을 하나씩 확인하기
for plan in plans:
    # 이동 후 좌표 구하기
    for i in range(len(move_types)):
        if plan == move_types[i]: # move_types와 plan이 같을 때 좌표 이동
          nx = x + dx[i]          # 이동한 경로. 초기화를 안하고 바로 선언해도 된다.
          ny = y + dy[i]
    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    # 이동 수행
    x, y = nx, ny

print(x, y)
```



## <문제> 시각

### 문제 설명

> 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성



### 문제 조건

* 풀이 시간 : 15분
* 시간제한 : 2초
* 메모리 제한 : 128MB
* 입력 조건 : 첫째 줄에 정수 N이 입력된다.(0 <= N <= 23)
* 출력 조건 : 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력



### 문제 해결 아이디어

* **가능한 모든 시각의 경우를 하나씩 모두 센다.**
* 시각을 1씩 증가시키면서 3이 하나라도 포함되어 있는지를 확인
* 이러한 유형을 **완전 탐색(Brute Forcing)** 문제 유형이라고 부른다.
  * 가능한 경우의 수를 모두 검사해보는 탐색 방법



### 답안 예시

```python
# H 입력 받기
h = int(input())

count = 0
for i in range(h + 1): # 입력한 시간까지
    for j in range(60): # 분 단위
        for k in range(60): # 초 단위
            # 매 시각 안에 '3'이 포함되어 있다면, 카운트 증가
            if '3' in str(i) + str(j) + str(k): # 시, 분, 초 하나라도 3이 있는지 문자열로 합쳐서 확인
                count += 1
print(count)
```



## <문제> 왕실의 나이트

### 문제 설명

> 왕실 정원은 8 x 8 좌표 평면 (행 1 ~ 8, 열 a ~ h)
>
> 특정한 한 칸에 나이트가 서 있다.
>
> 나이트는 이동 시, L자 형태로만 이동하고 정원 밖으로는 나갈 수 없다.
>
> 나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동
>
> 1 ) 수평으로 두 칸 이동한 뒤에 수직으로 한 칸
>
> 2 ) 수평으로 한 칸 이동한 뒤에 수직으로 두 칸
>
> 나이트가 이동할 수 있는 경우의 수를 출력하라



### 문제 조건

* 풀이 시간 : 20분
* 시간 제한 : 1초
* 메모리 제한 : 128MB
*  입력 조건 : 첫째 줄에 8x8 좌표 평면상에서의 나이트 위치가 두 문자로 입력
* 출력 조건 : 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력



### 문제 해결 아이디어

* 구현 문제
* 나이트의 8가지 경로를 하나씩 확인하며 각 위치로 이동이 가능한지 확인
  * 리스트를 이용하여 8가지 방향엗 대한 방향 벡터를 정의



### 답안 예시

```python
# 현재 나이트의 위치 입력 받기
input_data = input()
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1 # 열의 문자를 숫자로 변환

# 나이트가 이동할 수 있는 8가지 방향 정의
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] # 하나의 리스트로 방향 벡터 정의 가능

# 8 가지 방향에 대하여 각 위치로 이동이 가능한지 확인
result = 0
for step in steps:
    # 이동하고자 하는 위치 확인
    next_row = row + step[0]       # 행의 이동을 찾아 더하기
    next_column = column + step[1] # 열의 이동을 찾아 더하기
    # 해당 위칠 이동이 가능하다면 카운트 증가
    if next_row >=1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
        result += 1

print(result)
```



## <문제> 문자열 재정렬

### 문제 설명

>  알파벳 대문자와 숫자(0 ~ 9)로만 구성된 문자열이 입력으로 주어진다.
>
> 모든 알파벳을 오름차순으로 정렬해서 이어 출력한 뒤, 그 뒤에 모든 숫자를 더한 값을 이어서 출력



### 문제 조건

* 풀이 시간 : 20분
* 시간 제한 : 1초
* 메모리 제한 : 128MB
* 입력 조건 : 첫째 줄에 하나의 문자열 S가 주어진다.(1 <= S의 길이 <= 10,000)
* 출력 조건 : 첫째 줄에 문제에서 요구하는 정답을 출력



### 문제 해결 아이디어

* 요구사항대로 구현
* 문자열 입력 시, 문자를 하나씩 확인
  * 숫자인 경우 따로 합계 계산
  * 알파벳은 별도의 리스트 저장



### 답안 예시

```python
data = input()
result = []
value = 0

# 문자를 하나씩 확인
for x in data:
    # 알파벳인 경우 결과 리스트에 삽입
    if x.isalpha():
        result.append(x)
    # 숫자는 따로 더하기
    else:
        value += int(x)

# 알파벳을 오름차순 정렬
result.sort()

# 숫자가 하나라도 존재하는 경우 가장 뒤에 삽입
if value != 0:
    result.append(str(value)) # 숫자의 합을 문자열 처리한 뒤 결과 리스트 삽입

# 최종 결과 출력(리스트를 문자열로 변환하여 출력)
print(''.join(result))
```

























