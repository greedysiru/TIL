# 11장 - 원시 값과 객체의 비교

**본 내용은 모던 자바스크립트 Deep Dive - 자바스크립트의 기본 개념과 동작 원리를 토대로 작성하였습니다.**



## 11.0 원시 타입 vs. 객체 타입

* 원시 타입(Primitive Type)
  * 숫자, 문자열, 불리언, null, undefiend, 심벌
  * **변경 불가능한 값(Imumtuable Value)**
  * 값에 의한 전달: 원시 값 변수를 다른 변수에 할당하면 그 값을 복사함
* 객체 타입(Object/Reference Type)
  * 객체
  * **변경 가능한 값(Mutable Value)**
  * 참조에 의한 전달: 참조 값 변수를 다른 변수에 할당하면 참조 값을 전달



## 11.1 원시 값

### 11.1.1 변경 불가능한 값

* 한번 생성된 원시 **값**은 읽기 전용 값으로 변경할 수 없음
  * 읽기 전용 값
  * 변수와 혼동 주의
  * 변수에 할당하는 값은 무엇이든 변경할 수 있지만 원시 값 자체는 변경이 불가능하다는 뜻
* 데이터의 신뢰성 보장



#### 변수 vs. 상수

* 둘 다 메모리 공간을 식별하기 위한 용도로 사용
* 변수: 재할당이 가능
  * var, let 키워드
* 상수: 재할당이 불가능
  * 단, 상수에 참조값이 할당되는 경우 변경할 수 있음



#### 원시 값의 할당

* 원시 값을 할당하고 있는 변수에 새로운 원시 값을 할당하면
  * 새로운 메모리 공간을 확보
  * 할당할 원시 값을 저장
  * 변수는 확보된 새로운 메모리 공간 주소를 가리키게 됨
* 원시 값 자체는 변경이 불가하므로 이렇게 동작(**Immutability**)



#### 원시값 - 불변성의 의도

* 데이터의 신뢰성 보장
* 상태 변경의 추적 용이



### 11.1.2 문자열과 불변성

* 0개 이상의 문자로 이뤄진 집합
* 문자 1개는 1바이트의 메모리 공간에 저장
  * 문자가 많아질 수록 그만큼 필요한 메모리 공간이 많아짐
  * cf) 숫자의 경우는 값의 크기에 상관 없이 동일한 8바이트가 필요
* 원시 타입
* 유사 배열 객체이며 이터러블
  * 배열과 유사하게 접근 가능



#### 유사 배열 객체

* 문자열은 유사 배열 객체이므로 인덱스로 접근 가능
* length프로퍼티를 가짐
* for문으로 순회 가능
* **단, 배열과 같이 인덱스에 접근하여 새로운 값을 할당하는 것은 불가능**
  * **문자열의 불변성**
  * 에러는 발생하지 않음

```JavaScript
const introduceMyPet = '내 고양이 이름은 시루입니다.';

// 인덱스로 접근 가능
console.log(introduceMyPet[0]); // 내

// 배열의 프로퍼티에 접근가능하며 for문으로 순회 가능
for (let i = 0; i < introduceMyPet.length; i++) {
  console.log(introduceMyPet[i]); // 위의 조건대로 문자열을 하나씩 접근하여 console.log 로 출력
}
```



### 11.1.3 값에 의한 전달

* 공유에 의한 전달이라고도 표현
* 이미 원시 값이 할당되어 있는 변수를 다른 변수에 할당할 시 그 원시값을 복사하여 할당하게 됨
  * ECMAScript 사양에서 명확하게 정의되어 있지 않아 엔진에 따라 차이가 있을 수 있음
  * **두 변수의 원시 값은 서로 간섭할 수 없음**
* 엄밀히, 변수에는 값이 아니라 메모리 주소가 전달 되는 것
  * 식별자는 값 자체를 가지는 것이 아니라 메모리 주소를 가지는 것이므로

```JavaScript
let myCatName1 = 'siru';
// myCatyName1에 할당된 원시값을 복사하여 메모리 공간 확보 후 할당
// myCatName1 과 myCatName2의 값 자체는 똑같지만 메모리 공간은 다름
let myCatName2 = myCatName1;

console.log(myCatName1); // siru
console.log(myCatName2); // siru

// myCatName1에 다른 값을 할당하여도 myCayName2의 값에는 영향이 없음
myCatName = 'nunu';

console.log(myCatName1); // nunu
console.log(myCatName2); // siru
```



## 11.2 객체

* 동적으로 추가 및 삭제 가능
* 원시 값에 비해 상대적으로 차지하는 메모리가 큼
* 해시 테이블과 유사한 방식으로 구현 됨
  * 클래스 없이 객체 생성
  * 동적으로 프로퍼티 및 메서드 추가 가능
  * 사용성은 좋으나 성능 차원에서 비효율적
  * V8 엔진에서는 이를 보완(동적 탐색, 히든 클래스)



### 11.2.1 변경 가능한 값

* 변수에 객체를 할당하면 객체가 저장된 메모리 공간 주소(참조 값)을 가지게 됨
* 재할당 없이 객체를 직접 변경 가능
  * 동적으로 프로퍼티 추가, 삭제, 수정 가능
  * 변수의 참조 값 자체는 변경되지 않음



#### 참조 값 - 변경 가능한 이유

* 참조 값인 객체는 원시 값인 데이터들 보다 크기가 큼
  * 복사하여 생성하는 비용이 많이 듦
  * 메모리의 효율적 소비가 어려움
* 신뢰성을 희생하는 대신 효율성과 성능을 위해 변경 가능한 값으로 취급



### 11.2.3 참조에 의한 전달

* 참조 값이 복사되어 전달



#### 주의 할 점

* 여러 변수가 하나의 객체를 공유 가능
* 한 변수에 참조 값이 할당되어 있을 때 그 변수를 다른 변수에 할당하면 참조값이 그대로 할당 됨
  * 다른 변수도 원본 객체에 접근이 가능하게 됨
  * 다른 변수에서도 프로퍼티나 메서드의 수정이 가능하여 예기치 못한 문제를 일으킴
* 얕은 복사와 깊은 복사를 하여 이 문제를 방지하기
  * 얕은 복사 : 한 단계 까지 복사
  * 깊은 복사 : 객체 안의 객체까지 복사

```JavaScript
const petInfo = {
  name: 'siru',
  age: 6,
  isCat: true,
}

// 참조에 의한 전달
// 두 변수 모두 같은 참조 값을 바라보게 됨
const myPet = petInfo;

// 동적 수정
myPet.name = 'nunu';

// myPet에서 name 프로퍼티를 수정한 것이라도 원본 객체의 프로퍼티가 수정되어 다른 변수에서도 해당 프로퍼티가 바뀌게 됨
console.log(petInfo.name); // nunu
console.log(myPet.name); // nunu
```





### 11.2.4 값에 의한 전달 vs. 참조에 의한 전달

* 두 방식 모두 메모리 주소를 전달한다는 것은 동일
* 값에 의한 전달은 주소를 전달하기 전에 값을 복사하여 별도의 새 메모리 공간에 할당
* 참조에 의한 전달은 같은 주소를 그대로 전달

